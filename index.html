<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shangc1016","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="shangc&#39;s blog">
<meta property="og:url" content="https://shangc1016/shangc1016.github.io/index.html">
<meta property="og:site_name" content="shangc&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="Shang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://shangc1016/shangc1016.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>shangc's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">shangc's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://shangc1016/shangc1016.github.io/2022/05/02/xv6-address-space/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shangc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/02/xv6-address-space/" class="post-title-link" itemprop="url">xv6-address-space</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-02 17:28:13" itemprop="dateCreated datePublished" datetime="2022-05-02T17:28:13+08:00">2022-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 12:07:54" itemprop="dateModified" datetime="2022-05-04T12:07:54+08:00">2022-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章、页表"><a href="#第三章、页表" class="headerlink" title="第三章、页表"></a>第三章、页表</h1><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>xv6运行在Sv39的RISC的机器上，39表示用到了机器64位的低39位，高25位没有用到。在这样的设置中，逻辑页表是一个2的27次方大小的页表项数组（39 - 12 &#x3D; 27）。每个页表项包括一个44位的物理页号，以及10位的校验位。实际使用用不了这么多的物理页，因为2的54次方太大的，因此物理页号的高位是0。RISC-V的实现是三级页表，一个虚拟地址经过页表项的三次翻译变成物理地址。页表保存在内存中，构成一个三层的树。树根是4k大小的一页，包括512（4k &#x2F; 512 &#x3D; 8byte &gt; 54bit）个页表项PTE。页表就是对每个进程地址空间的描述。</p>
<p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220427211356339.png" alt="image-20220427211356339"></p>
<p>为了打开页表机制，需要把根页表的地址写入satp寄存器。每个CPU有一个单独的satp寄存器。因此每个CPU可以根据不同的页表进行地址转化。在进入内核态时，satp寄存器指向内核的根页表地址。在用户进程中，寄存器指向用户进程的根页表地址。在系统最初初始化的时候，在<code>kernel/start.c</code>中就写apt寄存器为0，即禁用分页机制。</p>
<h4 id="Direct-Mapping"><a href="#Direct-Mapping" class="headerlink" title="Direct Mapping"></a>Direct Mapping</h4><p>内核为了能够处理一些硬件资源等，会把一部分的物理地址直接映射到同一个虚拟地址，这个叫做“direct mapping”。例如，在物理地址以及虚拟地址，内核的起始地址都位于0x80000000。直接内存映射简化了内核读写物理内存。例如，fork创建子进程，内存分配器返回物理内存，然后内核把这个地址直接当成虚拟地址进行处理，省略了一步地址转化。</p>
<p>同时，还有一部分内存不是直接映射的：</p>
<ul>
<li>trampoline的内存页：这个内存页被映射到了虚拟内存的地址最高端（trampoline在内核中被映射了两次，一次到地址最高端，一次是直接映射）</li>
<li>内核栈页面：每个进程都有一个内核栈，这个内核栈映射到地址高端，防止可能的地址越界造成对其他正在使用页面的污染。（把这个很重要的数据保护起来，放在平常访问不到的地址高端）</li>
</ul>
<p>使用直接映射的内核栈地址也可以，就是这样做不好处理可能的内存越界，因为和其他的数据挨得比较近。如果有地址越界，造成其他页面的数据被覆盖，单纯的内核异常不能处理这个问题。</p>
<p>每个CPU有一个寄存器SATP寄存器，这个寄存器存放的是当前进程的第一级页表的地址，这个地址，以及页表项PTE里面的地址（索引下一级的页表），这个地址都是物理地址。因为页表的目的就是虚拟地址与物理地址的转换，这儿还是虚拟地址的话，就陷入了无尽的循环。</p>
<p>因为三级页表的存在，翻译一个虚拟地址需要读内存三次才能转为物理地址。这个太慢了，于是有了TLB的存在，这个是一个硬件CPU层面东西，我们只需要知道他的存在就行。在RISCV中，指令sfence_vma 清空TLB缓存。不同的进程有自己不同的页表，在进程切换时，TLB也需要清空。</p>
<p>xv6中的walk函数实现了MMU硬件相同的功能</p>
<p>既然有MMU的硬件，那为啥需要一个walk函数，实现相同的逻辑？</p>
<p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220427233535418.png" alt="image-20220427233535418"></p>
<blockquote>
<p>解释一下，这个就是说，通常情况下，每个进程只需要用到自己的内存空间，使用自己的pagetable。这样的话，pagetable由MMU实现，不需要walk函数是完全可以的。但是针对copyin、copyout这种情况，内核进程需要直接对用户进程的内存空间进行数据的读写。就是需要访问其他的进程，这个需要显式的调用。也就是为啥会有walk函数的存在。不知道说的对不对？</p>
</blockquote>
<h4 id="用户进程空间布局"><a href="#用户进程空间布局" class="headerlink" title="用户进程空间布局"></a>用户进程空间布局</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Virtual_address_space_and_physical_address_space_relationship.svg/600px-Virtual_address_space_and_physical_address_space_relationship.svg.png" alt="img"></p>
<p>其中，program break就指的是内存布局中data段的末尾。brk、sbrk的语义就是把program break后移，空出新的内存空间，返回给用户。这个就是heap堆区的增长方式。</p>
<h4 id="sbrk分配器"><a href="#sbrk分配器" class="headerlink" title="sbrk分配器"></a>sbrk分配器</h4><blockquote>
<p>xv6中的这个slab和linux中的slab不一样，linux中的slab是针对字节大小的小内存分配的设计。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// PGROUNDUP 他的作用是给出sz对应的页面上取整</span></span><br><span class="line"><span class="comment">// PGROUNDUP(4095) = 4096,PGROUNDUP(4096) = 4096,PGROUNDUP(4097) = 8192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// PGROUNDDOWN 他的作用是给出sz对应的页面下取整</span></span><br><span class="line"><span class="comment">// PGROUNDDOWN(4095) = 0,PGROUNDUP(4096) = 4096,PGROUNDUP(4097) = 4096</span></span><br></pre></td></tr></table></figure>

<p>用户进程的malloc函数会调用sbrk这个系统调用<code>user/umalloc.c</code>,然后调用<code>kernel/proc.c</code>中的<code>growproc</code>,即扩张program brea;接着调用uvmalloc,可以看到这种分配方式是以页面为单位的，计算了oldsz、newsz之间差几个页面，然后kalloc分配对应的物理页面，并且映射到相应的program break位置上去。最后更新p-&gt;sz &#x3D; newsz;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">uint64 <span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  a = oldsz;</span><br><span class="line">  <span class="keyword">for</span>(; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="buddy分配器"><a href="#buddy分配器" class="headerlink" title="buddy分配器"></a>buddy分配器</h4><blockquote>
<p>参考ULK,312页伙伴系统</p>
<p>参考MOSPI,62页buddy system, slab</p>
</blockquote>
<p><img src="https://www.researchgate.net/profile/Nada-Abdullah/publication/329809459/figure/fig1/AS:705894601986049@1545309796418/Data-structures-used-by-the-buddy-system-4.ppm" alt="Data structures used by the buddy system [4] | Download Scientific Diagram"></p>
<p>buddy分配器把所有空闲页分为多个链表，每个块链表包含大小为1，2，4，8…的<strong>物理连续页框</strong>。</p>
<p>步骤：</p>
<ol>
<li>需要大小为n个页面的内存，先对n上取整到2^k;</li>
<li>在buddy的链表上对应的2^k上找，找到返回，并更新bitmap</li>
<li>没找到，在更大的块链表上找，找到一半返回给用户，一半加入上一级链表；以此类推。</li>
<li>维护bitmap，合并buddy。</li>
</ol>
<p>怎么确定buddy中的伙伴？</p>
<ul>
<li>buddy数组中的每一项指向一个链表，分表表示大小为1，2，4，8…个连续物理页面的地址</li>
<li>以第一个链表，即大小为一个页面的为例。假设第一个物理页面地址0x0000,则第二个物理页面地址0x1000,两者互为伙伴。地址只差一位，而且在第12位，而且这个链表大小4K(2^12)。</li>
</ul>
<h4 id="malloc与free的实现"><a href="#malloc与free的实现" class="headerlink" title="malloc与free的实现"></a>malloc与free的实现</h4><blockquote>
<p>TODO</p>
<p>参考TLPI，page117</p>
</blockquote>
<h1 id="Lab-Allocator-for-xv6"><a href="#Lab-Allocator-for-xv6" class="headerlink" title="Lab: Allocator for xv6"></a>Lab: Allocator for xv6</h1><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ul>
<li>修改<code>kernel/file.c</code>，使用buddy分配器，使得打开文件数不受NFILE限制</li>
<li>buddy分配器空间利用不高效。对于buddy系统关系的每种大小的每个内存块，需要用一位来记录是否在使用。一个优化是对于buddy中的一对内存块，只是用一位表示，即B1_is_free异或B2_is_free。对于一对buddy内存B1、B2,每当有一个块被释放或者分配，就翻转这个数。例如：如果B1、B2都分配了则置为为0，如果B1被释放，翻转为1。如果这一位是1并且B2被释放，我们就需要合并B1B2。这样buddy管理的每个块节省了1&#x2F;2个bit。当buddy管理128M内存的时候，大概可以节省1MB内存。</li>
</ul>
<blockquote>
<p>整个lab只需修改<code>kernel/buddy.c</code>和<code>kernel/file.c</code></p>
</blockquote>
<h4 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h4><ul>
<li>移除<code>kernel/file.c</code>的第19行。在<code>filealloc</code>中使用<code>bd_malloc</code>分配<code>struct file</code>结构体。然后在<code>fileclose</code>中释放分配的内存</li>
<li><code>fileclos</code>需要获得ftable.lock，因为这个锁保护<code>f-ref</code></li>
<li><code>bc_alloc</code>并不会清空分配得到的内存，需要在使用前由调用者手动清空</li>
<li>使用<code>bd_print</code>打印分配器的状态</li>
<li>与讲义相比，我们修改了<code>bd_init</code>。因此，这个函数调用的内存是他可用的物理内存范围，与讲义相比，我们已经修改了bd_init，因此可以将其调用，可用于分配的物理内存范围。 BD_Init从该内存分配了Buddy数据结构的内存。它相应地初始化了数据结构：BD_INIT标记了用于分配的好友数据结构的内存，以免重新分配。此外，我们已经修改了BD_INIT，以处理一定数量的内存，这些内存不是通过将不可用的内存标记为分配的2的功率。最后，我们修改了伙伴分配器，以使用锁来序列化并发调用。</li>
</ul>
<h4 id="选做"><a href="#选做" class="headerlink" title="选做"></a>选做</h4><ul>
<li>把其他的数据结构改为动态申请内存的方式，proc数据结构需要大幅修改，别的还可。</li>
</ul>
<blockquote>
<p>TODO: 先把buddy.c看明白orz</p>
</blockquote>
<hr>
<ul>
<li>xv6中的buddy和linux中的还有不同，linux中的buddy是针对物理页面的一种内存管理器。在xv6中buddy管理的内存粒度似乎要更小？最小的内存块大小LEAF_SIZE &#x3D; 16字节？？在系统初始化之后所有的内存全部交给buddy管理，内存大小几乎等于128MB。所以buddy数组的大小也大得多，长度为24。</li>
<li>互为buddy的块物理内存连续，在xv6的buddy中，采用序号的方式.互为buddy的两个块的序号为(n,n+1)其中n为偶数。</li>
</ul>
<hr>
<h4 id="xv6-buddy源码"><a href="#xv6-buddy源码" class="headerlink" title="xv6-buddy源码"></a>xv6-buddy源码</h4><h6 id="bd-init"><a href="#bd-init" class="headerlink" title="bd_init"></a>bd_init</h6><p>首先调试一下main.c，其中用到了buddy 来初始化内核物理内存。过程中发现一个错误，riscv64-unknown-elf-gdb调试器无法打印出local variable，最后解决<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/68501265/cannot-access-memory-when-debugging-xv6-user-program-using-gdb">参考</a>，在CFLAGS中加一个参数<code>-gdwarf-2</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sz_info</span> &#123;</span></span><br><span class="line">  Bd_list <span class="built_in">free</span>;</span><br><span class="line">  <span class="type">char</span> *alloc;</span><br><span class="line">  <span class="type">char</span> *split;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个是buddy的结构体，其中free是双向链表，链接下一个同样大小的空闲块</span></span><br><span class="line"><span class="comment">// alloc表示这种大小空闲块的分配情况</span></span><br><span class="line"><span class="comment">// split表示这种大小空闲块的分割情况</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先进入到bd_init;bd_init初始化了buddy的元数据部分，即地址0x8002000到0x88000000;然后调用bd_initfree初始化空闲内存。</p>
</li>
<li><p>分别初始化这个长度为24的数组的alloc以及split。他的长度表示这个大小的块的最大个数，每个块的状态用一位表示。</p>
<blockquote>
<p>因为块大小为16B的已经是最小的，必能继续分割了。所以其没有split数组。代码中从下表1开始</p>
</blockquote>
</li>
<li><p>然后把buddy系统的元数据所占用的内存在buddy系统中标记为1，即在使用；同样的把end地址上取整的部分地址是不可用的，同样标记为1。</p>
</li>
<li><p>在kinit之后，打印出buddy的状态</p>
<ol>
<li><p>根据代码注释，这儿的alloc作为bitmap记录那些亏被分配出去了，split记录那些块被分割了；但是为啥打印处理的alloc和split一样呢？TODO</p>
</li>
<li><p>根据这个输出布局可以看到，alloc已经分配出去的内存分为两部分，一部分是前面的buddy的元数据，后面的一块内存是上取整留出来的无法使用的内存。然后观察对于每种块大小的freelsit、组合起来刚好完全覆盖了空闲内存区域</p>
<blockquote>
<p>以大小为16B的做个解释：每块大小16B,最多有8388604个块，共计128MB内存。freelist只有一个，说明只有管理内存的左侧或者右侧有一个空间，其余空闲都在严格内部。196657*16&gt;&#x3D;3146512,即表示0到196657这些块被buddy的元数据占用；8388608-8377856&#x3D;0x2a00，表示从8388608到8377856的物理page属于不可用的页面。</p>
<ul>
<li>有的没有freelist，说明管理的可用内存刚好margin&#x3D;块大小，buddy彼此被完整分割</li>
<li>有的freelist不止一个，说明管理的可用内存左右边界刚好各自用了一个块，剩下一个buddy成为free空闲状态。</li>
</ul>
</blockquote>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">bd: memory sz is 134045696 bytes; allocate an size array of length 24</span><br><span class="line">bd: 3146512 meta bytes for managing 134217728 bytes of memory</span><br><span class="line">bd: 0x2a000 bytes unavailable</span><br><span class="line">size 0 (blksz 16 nblk 8388608): free list:  0x000000008032a310</span><br><span class="line">  alloc: [0, 196657) [8377856, 8388608)</span><br><span class="line">size 1 (blksz 32 nblk 4194304): free list:  0x000000008032a320</span><br><span class="line">  alloc: [0, 98329) [4188928, 4194304)</span><br><span class="line">  split: [0, 98329) [4188928, 4194304)</span><br><span class="line">size 2 (blksz 64 nblk 2097152): free list:  0x000000008032a340</span><br><span class="line">  alloc: [0, 49165) [2094464, 2097152)</span><br><span class="line">  split: [0, 49165) [2094464, 2097152)</span><br><span class="line">size 3 (blksz 128 nblk 1048576): free list:  0x000000008032a380</span><br><span class="line">  alloc: [0, 24583) [1047232, 1048576)</span><br><span class="line">  split: [0, 24583) [1047232, 1048576)</span><br><span class="line">size 4 (blksz 256 nblk 524288): free list: </span><br><span class="line">  alloc: [0, 12292) [523616, 524288)</span><br><span class="line">  split: [0, 12292) [523616, 524288)</span><br><span class="line">size 5 (blksz 512 nblk 262144): free list: </span><br><span class="line">  alloc: [0, 6146) [261808, 262144)</span><br><span class="line">  split: [0, 6146) [261808, 262144)</span><br><span class="line">size 6 (blksz 1024 nblk 131072): free list:  0x000000008032a400</span><br><span class="line">  alloc: [0, 3073) [130904, 131072)</span><br><span class="line">  split: [0, 3073) [130904, 131072)</span><br><span class="line">size 7 (blksz 2048 nblk 65536): free list:  0x000000008032a800</span><br><span class="line">  alloc: [0, 1537) [65452, 65536)</span><br><span class="line">  split: [0, 1537) [65452, 65536)</span><br><span class="line">size 8 (blksz 4096 nblk 32768): free list:  0x000000008032b000</span><br><span class="line">  alloc: [0, 769) [32726, 32768)</span><br><span class="line">  split: [0, 769) [32726, 32768)</span><br><span class="line">size 9 (blksz 8192 nblk 16384): free list:  0x0000000087ffe000 0x000000008032c000</span><br><span class="line">  alloc: [0, 385) [16363, 16384)</span><br><span class="line">  split: [0, 385) [16363, 16384)</span><br><span class="line">size 10 (blksz 16384 nblk 8192): free list:  0x0000000087ffa000 0x000000008032e000</span><br><span class="line">  alloc: [0, 193) [8181, 8192)</span><br><span class="line">  split: [0, 193) [8181, 8192)</span><br><span class="line">size 11 (blksz 32768 nblk 4096): free list:  0x0000000080332000</span><br><span class="line">  alloc: [0, 97) [4090, 4096)</span><br><span class="line">  split: [0, 97) [4090, 4096)</span><br><span class="line">size 12 (blksz 65536 nblk 2048): free list:  0x0000000087fea000 0x000000008033a000</span><br><span class="line">  alloc: [0, 49) [2045, 2048)</span><br><span class="line">  split: [0, 49) [2045, 2048)</span><br><span class="line">size 13 (blksz 131072 nblk 1024): free list:  0x000000008034a000</span><br><span class="line">  alloc: [0, 25) [1022, 1024)</span><br><span class="line">  split: [0, 25) [1022, 1024)</span><br><span class="line">size 14 (blksz 262144 nblk 512): free list:  0x0000000087faa000 0x000000008036a000</span><br><span class="line">  alloc: [0, 13) [511, 512)</span><br><span class="line">  split: [0, 13) [511, 512)</span><br><span class="line">size 15 (blksz 524288 nblk 256): free list:  0x0000000087f2a000 0x00000000803aa000</span><br><span class="line">  alloc: [0, 7) [255, 256)</span><br><span class="line">  split: [0, 7) [255, 256)</span><br><span class="line">size 16 (blksz 1048576 nblk 128): free list:  0x0000000087e2a000</span><br><span class="line">  alloc: [0, 4) [127, 128)</span><br><span class="line">  split: [0, 4) [127, 128)</span><br><span class="line">size 17 (blksz 2097152 nblk 64): free list:  0x0000000087c2a000</span><br><span class="line">  alloc: [0, 2) [63, 64)</span><br><span class="line">  split: [0, 2) [63, 64)</span><br><span class="line">size 18 (blksz 4194304 nblk 32): free list:  0x000000008782a000 0x000000008042a000</span><br><span class="line">  alloc: [0, 1) [31, 32)</span><br><span class="line">  split: [0, 1) [31, 32)</span><br><span class="line">size 19 (blksz 8388608 nblk 16): free list:  0x000000008702a000 0x000000008082a000</span><br><span class="line">  alloc: [0, 1) [15, 16)</span><br><span class="line">  split: [0, 1) [15, 16)</span><br><span class="line">size 20 (blksz 16777216 nblk 8): free list:  0x000000008602a000 0x000000008102a000</span><br><span class="line">  alloc: [0, 1) [7, 8)</span><br><span class="line">  split: [0, 1) [7, 8)</span><br><span class="line">size 21 (blksz 33554432 nblk 4): free list:  0x000000008402a000 0x000000008202a000</span><br><span class="line">  alloc: [0, 1) [3, 4)</span><br><span class="line">  split: [0, 1) [3, 4)</span><br><span class="line">size 22 (blksz 67108864 nblk 2): free list: </span><br><span class="line">  alloc: [0, 2)</span><br><span class="line">  split: [0, 2)</span><br><span class="line">size 23 (blksz 134217728 nblk 1): free list: </span><br><span class="line">  alloc: [0, 1)</span><br><span class="line">  split: [0, 1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存布局</p>
<p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220504002217857.png" alt="image-20220504002217857"></p>
</li>
<li><p>空闲内存初始化；通过这种方式，其实就已经把所有的空闲内存区域管理起来了；块初始化示意图</p>
<blockquote>
<p>这块还不是很懂，画的图可能有bug</p>
</blockquote>
<p>![Untitled Diagram.drawio](<a target="_blank" rel="noopener" href="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgUntitled">https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgUntitled</a> Diagram.drawio.png)</p>
</li>
</ol>
<h6 id="bd-malloc"><a href="#bd-malloc" class="headerlink" title="bd_malloc"></a>bd_malloc</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从buddy中分配内存</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">bd_malloc</span><span class="params">(uint64 nbytes)</span>&#123;</span><br><span class="line">  <span class="type">int</span> fk, k;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find a free block &gt;= nbytes, starting with smallest k possible</span></span><br><span class="line">  fk = firstk(nbytes);</span><br><span class="line">  <span class="comment">// 首先对nbytes上取整为fk;</span></span><br><span class="line">  <span class="comment">// 比如申请大小为50B，则首先上取整为64，则fk=2 (16*2^2 &gt;= 64)</span></span><br><span class="line">  <span class="comment">// 如果申请大小500B,上取整为512,fk=5 (16*2^5 &gt;= 512)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后从下标为2的数组项开始找(每块大小64B),如果当前链表为空，找块大小更大的(k+1)</span></span><br><span class="line">  <span class="keyword">for</span> (k = fk; k &lt; nsizes; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!lst_empty(&amp;bd_sizes[k].<span class="built_in">free</span>))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k &gt;= nsizes) &#123; <span class="comment">// No free blocks?</span></span><br><span class="line">    release(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Found a block; pop it and potentially split it.</span></span><br><span class="line">  <span class="comment">// 找到之后， 把这个块标记为已经使用，</span></span><br><span class="line">  <span class="type">char</span> *p = lst_pop(&amp;bd_sizes[k].<span class="built_in">free</span>);</span><br><span class="line">  bit_set(bd_sizes[k].alloc, blk_index(k, p));</span><br><span class="line">  <span class="comment">// 把未分配的伙伴放到下一级链表中</span></span><br><span class="line">  <span class="comment">// 这块还没看明白TODO</span></span><br><span class="line">  <span class="keyword">for</span>(; k &gt; fk; k--) &#123;</span><br><span class="line">    <span class="comment">// split a block at size k and mark one half allocated at size k-1</span></span><br><span class="line">    <span class="comment">// and put the buddy on the free list at size k-1</span></span><br><span class="line">    <span class="type">char</span> *q = p + BLK_SIZE(k<span class="number">-1</span>);   <span class="comment">// p&#x27;s buddy</span></span><br><span class="line">    bit_set(bd_sizes[k].split, blk_index(k, p));</span><br><span class="line">    bit_set(bd_sizes[k<span class="number">-1</span>].alloc, blk_index(k<span class="number">-1</span>, p));</span><br><span class="line">    lst_push(&amp;bd_sizes[k<span class="number">-1</span>].<span class="built_in">free</span>, q);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="bd-free"><a href="#bd-free" class="headerlink" title="bd_free"></a>bd_free</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free memory pointed to by p, which was earlier allocated using</span></span><br><span class="line"><span class="comment">// bd_malloc.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bd_free</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">  <span class="type">void</span> *q;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;lock);</span><br><span class="line">  <span class="keyword">for</span> (k = size(p); k &lt; MAXSIZE; k++) &#123;</span><br><span class="line">    <span class="type">int</span> bi = blk_index(k, p);</span><br><span class="line">    <span class="type">int</span> buddy = (bi % <span class="number">2</span> == <span class="number">0</span>) ? bi+<span class="number">1</span> : bi<span class="number">-1</span>;</span><br><span class="line">    bit_clear(bd_sizes[k].alloc, bi);  <span class="comment">// free p at size k</span></span><br><span class="line">    <span class="comment">// 如果这块内存的伙伴已经被分配出去了，就直接把这块内存插入到当前的链表中</span></span><br><span class="line">    <span class="comment">// 伙伴被分配出去，说明已经不能和伙伴合并，然后变成更大的一块连续内存了</span></span><br><span class="line">    <span class="keyword">if</span> (bit_isset(bd_sizes[k].alloc, buddy)) &#123;  <span class="comment">// is buddy allocated?</span></span><br><span class="line">      <span class="keyword">break</span>;   <span class="comment">// break out of loop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// budy is free; merge with buddy</span></span><br><span class="line">    q = addr(k, buddy);</span><br><span class="line">    lst_remove(q);    <span class="comment">// remove buddy from free list</span></span><br><span class="line">    <span class="keyword">if</span>(buddy % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// at size k+1, mark that the merged buddy pair isn&#x27;t split</span></span><br><span class="line">    <span class="comment">// anymore</span></span><br><span class="line">    <span class="comment">// 如果伙伴仍然空闲，合并到下一个块大小的链表，也没看明白TODO</span></span><br><span class="line">    bit_clear(bd_sizes[k+<span class="number">1</span>].split, blk_index(k+<span class="number">1</span>, p));</span><br><span class="line">  &#125;</span><br><span class="line">  lst_push(&amp;bd_sizes[k].<span class="built_in">free</span>, p);</span><br><span class="line">  release(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="lab怎么做"><a href="#lab怎么做" class="headerlink" title="lab怎么做"></a>lab怎么做</h6><blockquote>
<p>orz</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://shangc1016/shangc1016.github.io/2022/04/26/xv6-trap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shangc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/xv6-trap/" class="post-title-link" itemprop="url">xv6-trap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-26 21:53:04" itemprop="dateCreated datePublished" datetime="2022-04-26T21:53:04+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-02 17:27:44" itemprop="dateModified" datetime="2022-05-02T17:27:44+08:00">2022-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="xv6的trap机制"><a href="#xv6的trap机制" class="headerlink" title="xv6的trap机制"></a>xv6的trap机制</h3><h4 id="syscall相关的riscv寄存器："><a href="#syscall相关的riscv寄存器：" class="headerlink" title="syscall相关的riscv寄存器："></a>syscall相关的riscv寄存器：</h4><ul>
<li>stvec：ecall 指令跳转到这儿执行，这个寄存器存放的是trampoline的地址；trampline汇编代码是用户空间进如内核空间的代码</li>
<li>sepc：ecall指令把用户空间的pc指针保存在此</li>
<li>scause：ecall将其设置为8，表示一个系统调用</li>
<li>sscratch： trapframe的地址</li>
<li>sapt（S-mode address translation and protection）：寄存器保存当前的页表基址</li>
<li>a0-a7：系统调用的参数</li>
<li>ra：返回地址</li>
<li>a0：返回值</li>
<li>a7：syscall的号码</li>
<li>tp：当前cpu线程号</li>
</ul>
<h4 id="Sv39地址翻译"><a href="#Sv39地址翻译" class="headerlink" title="Sv39地址翻译"></a>Sv39地址翻译</h4><p>可以看到，虚拟地址用到了64位中的低39位，即最大的虚拟地址空间0x4000000000</p>
<p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220502162140783.png" alt="image-20220502162140783"></p>
<h4 id="以write为例，说明系统调用的过程："><a href="#以write为例，说明系统调用的过程：" class="headerlink" title="以write为例，说明系统调用的过程："></a>以write为例，说明系统调用的过程：</h4><ul>
<li>write()<ul>
<li>trampoline &#x2F; uservec<ul>
<li>usertrap()<ul>
<li>syscall()<ul>
<li>sys_write()</li>
</ul>
</li>
</ul>
</li>
<li>usertrapret()</li>
</ul>
</li>
<li>trampoline &#x2F; userret</li>
</ul>
</li>
<li>write()返回</li>
</ul>
<p>以sh.c中的write系统调用为例子说明：</p>
<ol>
<li>首先查看sh.c的objdump代码sh.asm，查看到write函数直接调用的是<code>user/usys.S</code>的write函数，并且地址是<code>0000000000000d6a</code>，然后进入gdb调试。</li>
<li>在执行ecall指令之前，查看各个寄存器的值，包括pc、sapt、sepc、stvec、scause、sscratch以及a0</li>
<li>然后si单步执行ecall，进入到<code>kernel/trampoline.S</code>执行，<ol>
<li>首先，把sscratch寄存器与a0寄存器的值交换，然后此时a0寄存器就是trapframe的地址，即要把当前进程的寄存器保存到a0寄存器所存的地址对应的页表中。</li>
<li>最后跳转到进程结构体p-&gt;tf-&gt;kernel_trap处执行，（这个在<code>kernel/trap.c</code>中<code>usertrapret</code>中设置进程的内核trap处理函数为usertrap）</li>
</ol>
</li>
<li>然后进入<code>kernel/trap.c</code>的<code>usertrap</code>执，因为已经进入内核，首先在函数中切换中断处理为kernelvec</li>
<li>判断sscause寄存器的值是否为8，如果是8，就说明是来自用户空间的syscall。然后把寄存器epc的值保存到当前进程结构体中，并且epc+4，即反悔的时候直接执行ecall的下一条指令。</li>
<li>最后调用syscall()，根据寄存器a7选择相应的系统调用处理函数，最后把返回值置给寄存器a0，最后返回。</li>
<li>首先回到<code>usertrapret</code>函数中，设置进程关于内核的一些参数，如内核satp、kernel_sp进程的内核栈地址，进程trap的处理函数等，最后跳转到trampoline的userret处执行，重新从trapframe中把各个寄存器数据回复到物理的寄存器上，然后返回用户进程。</li>
</ol>
<h4 id="以initcode的系统调用为例："><a href="#以initcode的系统调用为例：" class="headerlink" title="以initcode的系统调用为例："></a>以initcode的系统调用为例：</h4><p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220502161616200.png" alt="image-20220502161616200"></p>
<h4 id="执行ecall："><a href="#执行ecall：" class="headerlink" title="执行ecall："></a>执行ecall：</h4><p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220502163333366.png" alt="image-20220502163333366"></p>
<h4 id="进入usertrap"><a href="#进入usertrap" class="headerlink" title="进入usertrap"></a>进入usertrap</h4><ul>
<li>设置stvec寄存器为kernelvec，表示已经进入内核，相应的中断处理要由内核完成。</li>
<li>判断scause寄存器的值，如果是8，表示syscall，先把epc+4，即返回的时候直接执行ecall的下一条指令</li>
<li>执行syscall函数，根据a7寄存器执行sys_xxx，返回值放在a0寄存器</li>
<li>进入usertrapret<ul>
<li>关中断，写stvec寄存器为trampoline的userret。当当前不处理其他的中断，唯一处理的是进程从内核返回用户态，使用的代码是trampoline中的userret。</li>
<li>设置好各种参数，包括设置epc为进程保存的epc、然后把sapt寄存器设置为当前进程的页表基址</li>
<li>最后执行trampoline中的userret，回复进程现场，返回到用户态，继续执行ecall的下一条指令</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>gdb调试：gdb调试有一个.gdbinit ，可以吧进入gdb之后的固定配置写到里面。执行命令gdb。首先执行这些命令。</li>
<li>进程优先级：通过nice 调整，nice的取值-20-19，数字越大，优先级越低</li>
<li>taskset：绑定进程到某个CPU执行</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://shangc1016/shangc1016.github.io/2022/04/23/xv6-lab-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shangc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/xv6-lab-shell/" class="post-title-link" itemprop="url">xv6-lab-shell</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-23 15:03:17" itemprop="dateCreated datePublished" datetime="2022-04-23T15:03:17+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-27 18:56:13" itemprop="dateModified" datetime="2022-04-27T18:56:13+08:00">2022-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Lab-Simple-xv6-shell"><a href="#Lab-Simple-xv6-shell" class="headerlink" title="Lab: Simple xv6 shell"></a>Lab: Simple xv6 shell</h2><p>写一个xv6的shell，可以处理输入输出、重定向、管道。</p>
<p>shell文件应该位于<code>user/nsh.c</code>，然后更新makefile，自己实现的shell中的prompt应该使用符号<code>@</code>，以便于和原本的shell的<code>$</code>区分。</p>
<h4 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h4><ul>
<li>不要使用动态内存分配如malloc，只能使用局部变量以及全局变量。（但是这个感觉有点骗测试的样子orz）</li>
<li>可以做出一些强制限制，比如命令的长度、参数的个数、每个参数的长度等（便于静态声明变量）</li>
<li>nsh的测试文件为testsh，运行方式为testsh nsh</li>
<li>不用merge之前的实验，也基本用不到之前的代码。</li>
<li>不用实现testsh中没有的测试点，比如对括号以及引用的解析</li>
<li>参考K&amp;R的C书， 比如5.12节的gettoken很有用</li>
<li>xv6的shell复杂的多，可以借鉴。复用代码须注释说明</li>
<li>可以使用用户空间的库<code>user/ulib.c</code></li>
<li>及时关闭不使用的文件描述符</li>
<li>所有的系统调用需要检查返回值，是否正确</li>
<li>testsh会重定向shell的标准输出，在shell中把error以及debug信息输出到fd 2。</li>
<li>关注testsh中的one函数，可能会有用。</li>
</ul>
<blockquote>
<p>intend：</p>
<ul>
<li>这个lab主要应该还是让用一用syscall，理解syscall过程。然后多用一用fork、exec、pipe，redirect等等吧。</li>
<li>那些东西是父子进程共享的，那些是独有的。然后看代码。</li>
</ul>
</blockquote>
<h4 id="管道："><a href="#管道：" class="headerlink" title="管道：|"></a>管道：|</h4><h4 id="重定向：-gt-、-lt"><a href="#重定向：-gt-、-lt" class="headerlink" title="重定向：&gt;、&lt;"></a>重定向：&gt;、&lt;</h4><p>对于管道和重定向同时存在的情况，管道的优先级要高，那就是先处理管道、再处理重定向。</p>
<ul>
<li>管道把命令分成了两部分，先执行管道左侧的命令，然后创建管道，写入数据；再执行右侧命令，从管道读数据，处理。</li>
<li>重定向负责把标准输入、输出、错误重定向到某个文件？<ul>
<li>对于重定向输出，fork执行&gt;左侧的命令的时候，设置重定向</li>
<li>对于重定向输入，fork执行&lt;右侧的命令的时候，设置重定向</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo hello there</span><br><span class="line">echo something &gt; file.txt</span><br><span class="line">ls | grep READ</span><br><span class="line">grep lion &lt; data.txt | wc &gt; count</span><br><span class="line">echo echo hello | nsh</span><br><span class="line">find . b | xargs grep hello</span><br></pre></td></tr></table></figure>







<h3 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h3><ul>
<li><p>遇到的第一个问题就是不太会处理字符串，然后也没有用sh.c中的其他函数。</p>
</li>
<li><p>第二个问题是不会读数据，最后发现构造的测试样例是每个命令以\n结尾。然后就是在读输入时，遇到\n就break，如果读到文件结束就退出，测试层序会多次调用nsh进程。</p>
</li>
<li><p>第三个问题就是我知道posix管道是半双工的，但是在父进程创建管道之后，写管道子进程没有关闭管道的读管道描述符；读管道子进程也没有关闭写管道描述符，然后造成了程序的undefined behavior，太蠢了。最后在ULK的page768找到解决方案。</p>
</li>
<li><p>最后一个坑是先写管道，写完之后要及时关闭写管道描述符，我只是在子进程中关闭了写管道描述符，但是在父进程中没有关（管道可以被多个进程读写、需要加锁保证数据可用），导致了后半段命令的子进程一直sleep，不能读到管道EOF，然后退出进程。</p>
<blockquote>
<p>这个问题在源代码中反映为user&#x2F;nsh.c中88-91行，debug之前是先两个wait，然后两个close。太蠢了。。。</p>
</blockquote>
</li>
</ul>
<h4 id="xv6-book片段"><a href="#xv6-book片段" class="headerlink" title="xv6-book片段"></a>xv6-book片段</h4><ul>
<li><p>fork和exec分成两步的原因就是在这两个徐彤调用中间可以插入一个IO重定向的部分。这样就能在不修改代码的情况下实现多个程序的连接</p>
</li>
<li><p>fork以及dup系统调用之后，父子进程对于同一个打开的文件描述符共享同一个文件偏移，因此下面的代码会输出hello,world到文件。这也是多个shell命令实现的方式。</p>
<p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220427151212572.png" alt="image-20220427151212572"></p>
</li>
<li><p>2&gt;&amp;1：这个命令的意思是对于shell命令，把文件描述符2设置为文件描述符1的复制，即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close（<span class="number">2</span>）;</span><br><span class="line">dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样做，可以让shell把标准输出和标准错误合并到同一个输出文件中。</p>
</li>
<li><p>管道pipe中，写管道结束之后，应该关闭管道的写一侧，否则管道的读一侧会一直阻塞。</p>
</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://shangc1016/shangc1016.github.io/2022/04/20/xv6-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shangc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/xv6-intro/" class="post-title-link" itemprop="url">xv6-intro</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-20 22:11:55" itemprop="dateCreated datePublished" datetime="2022-04-20T22:11:55+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-30 16:29:49" itemprop="dateModified" datetime="2022-04-30T16:29:49+08:00">2022-04-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote>
<p>环境：ubuntu20.04</p>
<p>跟着xv6-riscv-fall19做的：<a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-riscv-fall19">https://github.com/mit-pdos/xv6-riscv-fall19</a></p>
<p>Lab: Xv6 and Unix utilities：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2019/labs/util.html">https://pdos.csail.mit.edu/6.828/2019/labs/util.html</a></p>
</blockquote>
<p>安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure>

<p>clone代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:mit-pdos/xv6-riscv-fall19.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后检查一下分支</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现对应所有的几个实验，都有一个分支。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要做哪个实验，直接check进入，完成之后，`make grade`评分</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果哪个 <span class="built_in">test</span> point没过，会有对应的xxx.out日志文件打印相关信息方便debug。</span></span><br></pre></td></tr></table></figure>

<p>测试环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make qemu</span><br><span class="line">qemu-system-riscv64 --version</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个xv6目录下</span></span><br><span class="line">make qemu-gdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开新的终端，同样目录下</span></span><br><span class="line">gdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现有错 Undefined item: <span class="string">&quot;riscv:rv64&quot;</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后发现需要risc-gdb没有弄好，需要riscv的gdb，或者可以用8.3.1以上的gdb。</span></span><br></pre></td></tr></table></figure>



<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>首先在kernel.ld这个链接脚本中设置了起始的地址为0x80000000，这个地址也是qemu中首先跳转执行的地址。对应到源码中是<code>kernel/entry.S</code>，可以看到entry.S代码给每个硬件线程设置好sp寄存器，然后跳转到start。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_entry:</span><br><span class="line">	# set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">		csrr a1, mhartid    # mhartid：硬件线程id</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">	# jump to start() in start.c</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure>

<ul>
<li>其中la指令是伪指令（load address），stack0在start.c中定义，为每个cpu准备一个栈，每个栈大小写096</li>
<li><code>li</code>（load immediate），设置寄存器a0为4096</li>
<li>csrr(Control System Register)控制系统寄存器，读取数据到寄存器a1</li>
</ul>
<p>上面的步骤设置为start函数设置了相应的sp寄存器。然后进入<code>kernel/start.c</code>的<code>start()</code>函数中。</p>
<p>在start函数中，进行各种设置，设置异常程序计数器指针为main函数，即异常处理程序。在start函数中，设置计时器开始，</p>
<h4 id="Util"><a href="#Util" class="headerlink" title="Util"></a>Util</h4><ul>
<li><h4 id="实现用户进程sleep"><a href="#实现用户进程sleep" class="headerlink" title="实现用户进程sleep"></a>实现用户进程sleep</h4><ul>
<li>先看xv-book的第一章</li>
<li>参考其他的例子：<code>user/echo.c</code>，<code>user/grep.c</code> 等怎么从命令行接受参数</li>
<li>如果用户使用sleep命令没有给出参数，打印出错误信息</li>
<li>命令行参数是string类型，使用<code>user/ulib.c</code>中的函数<code>atoi</code>转换</li>
<li>使用sleep系统调用</li>
<li>在<code>kernel/sysproc.c</code>中查看sleep系统调用的实现，在<code>user/.h</code>中查看用户空间的sleep调用，在<code>user/usys.S</code>中查看从用户程序跳入内核的汇编程序。</li>
<li>最后确保sleep函数调用了<code>exit()</code>来退出程序。</li>
<li>在Makefile中的UPROGS中添加自己是先的sleep函数，然后编译，就可以在shell运行sleep。</li>
</ul>
<blockquote>
<p>额外的函数：实现uptime用户程序，打印系统启动uptime的ticks数。</p>
<p>解析：</p>
<ul>
<li>在<code>kernel/start.c</code>中的<code>start</code>函数中，调用了<code>timerinit()</code>，其中注释提到时钟中断间隔为1000000个interval、大概是1&#x2F;10秒。暂停用户定义的ticks，即sleep参数和用户输入一致。</li>
</ul>
</blockquote>
</li>
<li><h4 id="实现用户进程pingpong"><a href="#实现用户进程pingpong" class="headerlink" title="实现用户进程pingpong"></a>实现用户进程pingpong</h4><blockquote>
<p>利用管道实现一个ping-pong程序，父进程写入parent_id[1]一个字节，子进程从parent_id[0]读取这个字节，子进程读完之后，把数据写入child_id[1]，然后父进程再从child_id[0]读出来。</p>
</blockquote>
<ul>
<li>使用<code>pipe</code>创建管道</li>
<li>使用<code>fork</code>创建子进程</li>
<li>使用<code>read</code>、<code>write</code>读写数据</li>
<li>使用<code>getpid</code>得到进程号</li>
</ul>
<blockquote>
<p>这个比较简单，还用不到覆盖标准输入输出等；重定向</p>
<p>解析：<code>pipe</code>系统调用怎么实现的</p>
</blockquote>
</li>
<li><h4 id="实现用户进程primes"><a href="#实现用户进程primes" class="headerlink" title="实现用户进程primes"></a>实现用户进程primes</h4><blockquote>
<p>关于管道、重定向</p>
</blockquote>
<ul>
<li>写一个并发版本的素数过滤器，</li>
<li>使用fork以及pipe建立流水线、第一个进程把数字2-35打入pipe，从左到右输出每一个在其中的素数。</li>
<li>参考这个：<a target="_blank" rel="noopener" href="https://swtch.com/~rsc/thread/%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%9B%BE%E7%9A%84%E8%AF%B4%E6%98%8E%E5%B7%B2%E7%BB%8F%E9%9D%9E%E5%B8%B8%E6%B8%85%E6%A5%9A%E4%BA%86%E3%80%82">https://swtch.com/~rsc/thread/，这个图的说明已经非常清楚了。</a></li>
</ul>
</li>
</ul>
<p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20220419210709326.png" alt="image-20220419210709326"></p>
<ul>
<li><h4 id="实现用户进程find"><a href="#实现用户进程find" class="headerlink" title="实现用户进程find"></a>实现用户进程find</h4><ul>
<li>先看<code>user/ls.c</code>，明确怎么读目录</li>
<li>递归的遍历子目录</li>
<li>不用遍历<code>.</code>和<code>..</code></li>
<li>对文件系统的更改是持久化的，需要<code>make clean</code>、然后重新<code>make qemu</code></li>
<li>要用到C语言的strings</li>
</ul>
</li>
<li><h4 id="实现用户进程xargs"><a href="#实现用户进程xargs" class="headerlink" title="实现用户进程xargs"></a>实现用户进程xargs</h4><ul>
<li>从标准输入读入多行，然后依次执行</li>
<li>对于每行输入，使用fork以及exec系统调用。在父进程中使用wait等待子进程结束</li>
<li>每次从标准输入读一个字符，知道读到换行符\n</li>
<li>参考kernel&#x2F;param.h，中的MAXARG</li>
<li>对文件系统的更新是持久化的，通过make clean，重新编译make qemu</li>
</ul>
<blockquote>
<p>这儿遇到一个问题，在有argv的情况下，怎么读stdin？</p>
<p>最后发现是我太蠢了，运行程序<code>./xargs arg1 arg2 ...[\n回车]</code>，程序运行了，然后接下来的输入才对应的是从标准输入中独到的内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">./xargs grep hello</span></span><br><span class="line">./a/b</span><br><span class="line">./c/b</span><br><span class="line">./b</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令中<span class="string">&quot;grep hello&quot;</span>是命令行的参数，在输完hello，回车之后程序运行。接下来从./a/b开始的才是标准输入读的内容。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果用一个数组接收标准输入的数据，应该是“./a/b[space]./c/b[space]./b[\n]”</span></span><br></pre></td></tr></table></figure>

<p>最后遇到一个问题，给argv直接追加项，导致没追加签的argv的最后一项的值变了，最后把srgv以及标准输入读的参数复制到另一个数组解决。</p>
</blockquote>
</li>
</ul>
<h4 id="文件系统相关概念"><a href="#文件系统相关概念" class="headerlink" title="文件系统相关概念"></a>文件系统相关概念</h4><p>在find程序中，参考了ls。find的格式是<code>find &lt;path&gt; &lt;file&gt;</code>，即在路径下找到匹配的文件。那么首先即使要打开path这个文件，所有的路径对应于一个文件。</p>
<p>在文件系统的实现中，文件和目录其实没啥区别，区别仅在于目录文件中放的是目录信息。而文件里面放的是自定义的数据。</p>
<p>因此在实现中，先判断path的类型。</p>
<ul>
<li><p>如果是文件，判断是否和文件名相同，相同则输出。</p>
</li>
<li><p>如果是目录，就从次文件中读一个目录项，直到读完。针对每个读出来的目录项，递归的判断是文件还是目录，然后做相同的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在ls程序中，打印出了路径下的所有“文件”，包括文件，目录， 设备（在kernel&#x2F;stat.h，1表示目录，2表示文件，3表示设备）。“文件”的stat结构体相当于“文件”的元数据，定义在kernel&#x2F;stat.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中dev表示的是disk device，表示哪一个磁盘，ino表示在这个磁盘上的inode号码，type表示哪种“文件”，有文件、目录、设备三种；nlink表示链接数量；size表示文件的大小。</p>
<p>通过在xv6中运行ls程序：</p>
<p><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com/md-imgimage-20220423144333114.png" alt="image-20220423144333114"></p>
<p>得到的结果表示所有的文件都在同一个磁盘设备，第二列表示文件类型，第三列表示inode号，根据第四列文件大小可以计算inode号。可以看到在这个文件系统中，一个inode负责1kb大小的磁盘空间。</p>
<blockquote>
<p>TODO：关于生成文件系统这部分的代码在mkfs，随后在看。</p>
<p>关于怎么把kernel和fs.img链接起来，应该在kernel.ld 链接文件中或者makefile中，这个随后看。</p>
</blockquote>
<h4 id="Syscall"><a href="#Syscall" class="headerlink" title="Syscall"></a>Syscall</h4><p>在xv6的系统调用中，调用顺序是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_program --&gt; user_lib(ulib.c) --&gt; user_trap(usys.S) --&gt; syscall -&gt; sys_xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user_lib主要是对系统调用的一个wrap，也可以不调用user_lib，直接调用usys.S中的函数。</span></span><br></pre></td></tr></table></figure>

<ol>
<li>首先在<code>user</code>目录下的是用户程序，如<code>ls</code>、<code>cat</code>等。</li>
<li>上面这些代码可能会使用到系统调用，用户的库的头文件是<code>user/user.h</code>，声明了系统调用的接口。</li>
<li>库文件的实现在<code>user/usys.S</code>汇编代码真正<code>trap</code>进入内核<ol>
<li><code>riscv</code>的系统功能的汇编指令：<code>ecall</code>，携带参数进入内核。其中系统调用号放在寄存器<code>a7</code></li>
</ol>
<p>	</p>
</li>
<li>由内核中的<code>kernel/syscall.c</code>中的<code>syscall</code>函数作为系统调用的相应函数，根据不同的中断号执行不同的系统调用<code>sys_xxx</code>函数。</li>
</ol>
<h4 id="C语言内嵌汇编"><a href="#C语言内嵌汇编" class="headerlink" title="C语言内嵌汇编"></a>C语言内嵌汇编</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yt_42370304/article/details/84982864">https://blog.csdn.net/yt_42370304/article/details/84982864</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;xxx&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>asm：表示后面的是汇编代码</li>
<li>volatile：表示编译器不需要优化代码，后面的指令保持原样</li>
</ul>
<p>内嵌汇编语法：<code>__asm__(汇编模板语句：输出部分：输入部分：破坏描述部分)</code></p>
<p>%0,%1….代表参数，位置互相对应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mstatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;=r&quot;的意思是：变量放入通用寄存器，并且是只写的</span></span><br><span class="line"><span class="comment">// 对应的汇编：csrr [寄存器], mstatus；寄存器值与x变量绑定，x作为输出参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mstatus</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;r&quot;的意思是：变量放入通用寄存器</span></span><br><span class="line"><span class="comment">// 对应的汇编：csrr mstatus, [寄存器]；寄存器值与x变量绑定，x作为输入参数</span></span><br></pre></td></tr></table></figure>



<h4 id="源码安装gdb8-3-1"><a href="#源码安装gdb8-3-1" class="headerlink" title="源码安装gdb8.3.1"></a>源码安装gdb8.3.1</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PREFIX=$(pwd)/gdb-8.3.1-riscv64-linux-gnu</span><br><span class="line">wget ftp://ftp.gnu.org/gnu/gdb/gdb-8.3.1.tar.xz</span><br><span class="line">tar Jxf gdb-8.3.1.tar.xz</span><br><span class="line">mkdir gdb</span><br><span class="line">cd gdb</span><br><span class="line">../gdb-8.3.1/configure --program-prefix=riscv64-linux-gnu- --enable-tui --target=riscv64-linux-gnu --prefix=$&#123;PREFIX&#125;</span><br><span class="line">make all install</span><br></pre></td></tr></table></figure>



<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266502391">3.9 XV6 启动过程</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md</a></li>
<li><a target="_blank" rel="noopener" href="https://jborza.com/emulation/2021/04/22/ecalls-and-syscalls.html#:~:text=RISC%2DV%20offers%20an%20ecall,higher%20privileged%20code%20(kernel)">https://jborza.com/emulation/2021/04/22/ecalls-and-syscalls.html#:~:text=RISC%2DV%20offers%20an%20ecall,higher%20privileged%20code%20(kernel)</a>.</li>
<li>CSR（Control and Status Register Instructions）：读写寄存器</li>
<li>AUIPC（Add Upper Immediate to Program Counter）：这个指令把PC寄存器的高20位设置为操作数的和，低12位为0</li>
<li>在<code>kernel/syscall.c</code>中syscalls，系统调用数组声明为啥是这样的？<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17807103/array-assignment-by-index-while-declaration-in-c-language%EF%BC%9B%E8%BF%99%E6%A0%B7%E5%A3%B0%E6%98%8E%E5%8F%AF%E4%BB%A5%E4%B9%B1%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82emm">https://stackoverflow.com/questions/17807103/array-assignment-by-index-while-declaration-in-c-language；这样声明可以乱序初始化。emm</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://shangc1016/shangc1016.github.io/2022/04/06/xv6-x86-boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shangc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/xv6-x86-boot/" class="post-title-link" itemprop="url">xv6-x86-boot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-06 20:02:20" itemprop="dateCreated datePublished" datetime="2022-04-06T20:02:20+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 11:53:44" itemprop="dateModified" datetime="2022-05-04T11:53:44+08:00">2022-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="xv6-lab1-–-Booting-a-PC"><a href="#xv6-lab1-–-Booting-a-PC" class="headerlink" title="[xv6 lab1] – Booting a PC"></a>[xv6 lab1] – Booting a PC</h1><h3 id="计算机物理内存空间"><a href="#计算机物理内存空间" class="headerlink" title="计算机物理内存空间"></a>计算机物理内存空间</h3><p>早期的8086等处理器的物理内存布局如图所示，是20位总线的机器，因此其最大寻址空间是1MB；物理内存低地址端的640KB位系统可用内存、<code>640KB ~ 1MB</code>位系统其他资源的占用内存，其中最重要的部分是从<code>960KB ~ 1MB</code>地址的BIOS部分；其他部分由RAM组成，BIOS部分由ROM制度存储实现，后来由可重复读写的flash实现，满足BIOS升级等功能。</p>
<img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211009203208456.png" alt="image-20211009203208456" style="zoom:67%;" />



<p>从80286、80386开始机器总线扩展到32位，因此其最大物理寻址范围扩大到了4GB，为了物理内存布局的向后兼容性，在低地址端的1MB仍然保持了之前的内存布局。并且在32位机器上BIOS会使用4GB内存的高地址部分区域当作PCI设备的内存地址映射。因此在32位机器上，BIOS在整块内存上占了两个“洞”；</p>
<img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211009204231494.png" alt="image-20211009204231494" style="zoom:67%;" />



<h3 id="Step1：使用qemu"><a href="#Step1：使用qemu" class="headerlink" title="Step1：使用qemu"></a>Step1：使用qemu</h3><p>1、将实验环境搭建好，首先<code>make</code> 编译；可以看到编译之后新增加的文件，以及编译得到的结果<code>obj/kern/kernel.img</code>；</p>
<img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211009205128689.png" alt="image-20211009205128689" style="zoom:67%;" />

<p>2、<code>make qemu-gdb</code> 命令使用<code>qemu</code>调试编译产生的镜像文件；</p>
<img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211009205528695.png" alt="image-20211009205528695" style="zoom:67%;" />

<p>3、打开新的终端运行<code>make gdb</code>启动<code>gdb</code>调试；</p>
<img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211009205648899.png" alt="image-20211009205648899" style="zoom:67%;" />



<h3 id="Step2：BIOS"><a href="#Step2：BIOS" class="headerlink" title="Step2：BIOS"></a>Step2：BIOS</h3><p>1、使用<code>make gdb</code>命令进入<code>gdb</code>调试，可以看到<code>gdb</code>执行的第一条汇编指令<code>[f000:fff0] 0xffff0: ljmp $0x3630,$0xf000e05b</code>；即第一条指令地址位于<code>0xffff0</code>；此处好像是qemu的原因，实际长跳转到地址<code>0xfe05b</code>处执行；</p>
<p>2、由第一小节的物理内存布局可以看到，地址<code>0xffff0</code>已经是BIOS区域的最后16字节了，16字节不足以完成BIOS的功能， 因此使用长跳转到BIOS内存低地址区域继续执行；</p>
<p>3、即BIOS完成了硬件自检、设备初始化等设置，然后从磁盘中读取0号扇区（引导扇区）到内存地址<code>0x7c00</code>处，每个扇区大小512B，因此引导扇区所占内存<code>0x7c00 ~ 0x7dff</code>，最后BIOS逻辑跳转到引导扇区[CS：0x0000, IP：0x7c00]执行、将控制权转移到内核引导器；</p>
<blockquote>
<p>在20位机器或者在实模式中，物理地址<code>physics_address = CS * 16 + IP</code>；</p>
<p>CS、IP寄存器都是16位寄存器；16位寄存器怎么表示20位地址偏移呢？使用CS向左偏移4位加上IP的值就可以组成了20位地址；</p>
<p>BIOS干了什么：the BIOS intializes devices, sets of the interrupt routines, and reads the first sector of the boot device(e.g., hard-drive) into memory and jumps to it. </p>
</blockquote>
<img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211009210030129.png" alt="image-20211009210030129" style="zoom:67%;" />



<h3 id="Step3：Boot-Loader"><a href="#Step3：Boot-Loader" class="headerlink" title="Step3：Boot Loader"></a>Step3：Boot Loader</h3><p>在上一小节最后，BIOS通过跳转到<code>0x7c00</code> 将控制权交给内核引导器Boot Loader；Boot Loader在源码中主要由两个文件<code>/boot/boot.S </code>，<code>boot/main.c</code>组成；其中Boot Loader做了两个重要操作：1、从实模式转到32位保护模式；2、加载操作系统内核到内存；</p>
<p>1、<code>boot.s</code>在简单初始化之后打开了地址总线的A20地址线</p>
<blockquote>
<p>在早期的机器中总线是20位的，总线只有0~19，共1MB内存；后来内存扩展，为了保持向后兼容，A20地址线关闭表示地址译码为20位总线，打开表示使用更大的内存空间； </p>
</blockquote>
<p>2、<code>boot.s</code> 将CR0（control register控制寄存器）寄存器的0位置为1，开启保护模式、从实模式切换到保护模式；</p>
<img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211010140113617.png" alt="image-20211010140113617" style="zoom:67%;" />

<blockquote>
<p>CR0 寄存器；</p>
<p>PE（Protection Enable）开启保护模式：切换到保护模式后寻址方式发生变化，不再是之前的CS + IP，而是通过段选择子GDT、IDT等方式内存寻址；</p>
<p>PG （Paging） 开启分页机制</p>
</blockquote>
<p>3、<code>boot.s</code>设置好栈指针寄存器的值，最后跳转到<code>main.c</code>中的<code>bootmain</code>函数执行；</p>
<blockquote>
<p>内存布局中，栈指针只要给一个初值就行，此处设置的栈指针初值是start段的地址，就是说让栈指针指向start段的末尾，栈从该处开始增长；</p>
</blockquote>
<p>4、上一步跳转到了<code>bootmain</code> 函数中，其中主要的代码片段如下；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECTSIZE	512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFHDR		((struct Elf *) 0x10000) <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span>*, <span class="type">uint32_t</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(<span class="type">uint32_t</span>, <span class="type">uint32_t</span>, <span class="type">uint32_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// read 1st page off disk</span></span><br><span class="line">	readseg((<span class="type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 此处调用readseg函数，从磁盘起始读取SECTSIXZE*8字节数据到内存ELFHDR处;大小刚好是4KB，即一个page;</span></span><br><span class="line">    <span class="comment">// 在readseg函数内部，实际从0+1扇区取数据，即从第二个扇区读4KB数据;因为bootloader占用了磁盘的0号扇区;</span></span><br><span class="line">    <span class="comment">// 读取到目的地址ELFHDR，即物理地址0x10000;读入4KB,则这块数据所占内存空间为0x10000 ~ 0x10fff;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Q1: 为啥在此处读取4KB数据呢？</span></span><br><span class="line">    <span class="comment">// A: 4KB刚好是page的大小; 进一步查看kernel编译后的ELF文件，查看Program Header，可知有两个要加载到内存中的PH;</span></span><br><span class="line">    <span class="comment">//    其相对于kernel的ELF文件内的偏移分别是0x1000,0x9000;即第一个PH在ELF文件内的偏移为4KB;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">	<span class="comment">// is this a valid ELF?</span></span><br><span class="line">	<span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="comment">// 通过魔数判断是否是ELF文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">	ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    <span class="comment">// 加载到内存中的4KB数据为ELF头信息，包含了各个PH在ELF文件中的相对偏移，</span></span><br><span class="line">    <span class="comment">// 然后ph指针指向了第一个PH数据，</span></span><br><span class="line">    </span><br><span class="line">	eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="comment">// 此处是指针运算，ph是指针，ELFHDR-&gt;e_phnum得到了ELF文件中PH的个数，通过指针移位，eph指向了最后一个PH结构体;</span></span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">		<span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">		<span class="comment">// as the physical address)</span></span><br><span class="line">		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   		<span class="comment">// 加载PH到elf文件中指定的paddr;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">	<span class="comment">// note: does not return!</span></span><br><span class="line">	((<span class="type">void</span> (*)(<span class="type">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">    <span class="comment">// 最后跳转到elf文件的入口地址，强制类型转换为void*函数调用,把控制权转移给内核;</span></span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class="line"><span class="comment">// Might copy more than asked</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(<span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> count, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">	end_pa = pa + count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// round down to sector boundary</span></span><br><span class="line">	pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">	offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 传入0实际读取磁盘的1扇区;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">	<span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">	<span class="comment">// we load in increasing order.</span></span><br><span class="line">	<span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">		<span class="comment">// Since we haven&#x27;t enabled paging yet and we&#x27;re using</span></span><br><span class="line">		<span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">		<span class="comment">// use physical addresses directly.  This won&#x27;t be the</span></span><br><span class="line">		<span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">		readsect((<span class="type">uint8_t</span>*) pa, offset);</span><br><span class="line">		<span class="comment">// [sc]: offset might be the number of sector on disk</span></span><br><span class="line">		pa += SECTSIZE;</span><br><span class="line">		offset++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，bootmain函数先把内核的ElF文件头4KB读入内存，根据ELF头中的信息继续把内核中的多个Program Header 读入内存，最后跳转到内核entey执行，把控制权交给内核；</p>
<h4 id="Layout-of-Kernel-Program-Header"><a href="#Layout-of-Kernel-Program-Header" class="headerlink" title="Layout of Kernel Program Header"></a>Layout of Kernel Program Header</h4><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgimage-20211010143601304.png" alt="image-20211010143601304" style="zoom:67%;" />

<p>通过<code>objdump</code>查看kernel的ELF文件的Program Header，标记为LOAD的就是要加载到内存中的；</p>
<blockquote>
<p>off：该Program Header 在此ELF文件中的偏移量；</p>
<p>vaddr：该Program Header加载到内存中后在虚拟内存中的偏移量；</p>
<p>paddr：该Program Header加载到内存后在物理内存中的偏移量；</p>
<p>vaddr和paddr可能是由linker加载器手工设定的；</p>
</blockquote>
<p>至此，内核完全加载完成；</p>
<h3 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h3><img src="https://note-img-1300721153.cos.ap-nanjing.myqcloud.com//md-imgboot loader memory layout.svg" alt="image-20211010143601304" style="zoom:25%;" />


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Shang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
